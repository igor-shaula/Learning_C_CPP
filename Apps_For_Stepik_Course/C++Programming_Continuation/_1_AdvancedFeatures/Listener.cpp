/*
 * Шаблон "наблюдатель" можно объяснить на следующем примере.
 * Предположим, что мы программируем графический интерфейс.
 * Как нам связать объект-кнопку и действие, которое произойдёт, когда на кнопку нажмут?
 * Можно для каждой кнопки писать отдельный класс, но это приведёт к дублированию кода.
 * Вместо этого можно написать общий класс для кнопок
 * и настраивать объекты этого класса под каждую конкретную кнопку интерфейса.
 * Так для каждого объекта можно будет задавать, например, положение,
 * надпись на кнопке и соответствующее действие.
 * Для того, чтобы задавать действие, мы можем добавить в его интерфейс метод subscribe,
 * который позволяет подписаться на событие "кнопка нажата".
 */

// Например, в терминах ООП это могло бы выглядеть так:
struct Button;
// интерфейс, который реализуют все классы,
// объекты которые хотят подписаться на событие
// "кнопка нажата"
struct ButtonListener {
    // метод, который будет вызываться, когда
    // происходит событие "кнопка нажата"
    virtual void onButtonClick(Button *b, bool down) = 0;
    virtual ~ButtonListener() {}
};
// общий класс для кнопок
struct Button {
    // метод позволяет подписать объект класс,
    // реализующего интерфейс ButtonListener
    // на событие "кнопка нажата"
    void subscribe(ButtonListener *bl);
    // ...
};

// the same as before but without OOP but with pointers to functions -------------------------------
// Решение с помощью указателей на функции:
struct Button1;

// тип указателя на функцию, которая будет вызываться,
// когда событие "кнопка нажата"
typedef void (*ButtonProc)(Button1 *, bool, void *);

// общий класс для кнопок
struct Button1 {
    // метод позволяет подписать объект функцию
    // типа ButtonProc на событие "кнопка нажата"
    void subscribe(ButtonProc bp, void *arg);
    // ...
};