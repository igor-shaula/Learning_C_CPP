/*
Для ScopedPtr мы запретили копирование, однако, копирование можно и разрешить.
Это позволит реализовать более продвинутый умный указатель — SharedPtr.
Он отличается от ScopedPtr тем, что кроме хранения указателя на объект, он хранит еще и счетчик ссылок
(количество объектов SharedPtr, которые хранят один и тот же указатель).

Имея такой счетчик, мы можем определить момент, когда на объект, выделенный в куче,
не останется больше ссылок (когда счетчик ссылок станет равным 0), и освободить память.

Поддержка счетчика ссылок состоит из нескольких частей:

в конструкторе SharedPtr от ненулевого указателя мы инициализируем счетчик ссылок в 1
(конструктор создает первый SharedPtr, который хранит указатель),
в конструкторе копирования мы увеличиваем счетчик ссылок на 1,
если копируемый SharedPtr содержит ненулевой указатель
(конструктор копирования создает еще один SharedPtr с указателем на тот же самый объект),
в деструкторе мы уменьшаем значение счетчика на 1, если в объекте SharedPtr хранится ненулевой указатель
(мы удаляем один SharedPtr, который указывает на объект в куче),
оператор присваивания:
уменьшает счетчик ссылок левого операнда на 1, если внутри левого SharedPtr хранится ненулевой указатель,
увеличивает счетчик правого SharedPtr на 1, если в правом SharedPtr хранится ненулевой указатель
(обычное дело для оператора присваивания — сначала освобождаем старые ресурсы, потом выделяем новые,
но при этом нужно быть особенно внимательным с присваиванием самому себе).
Для класса SharedPtr могут оказаться полезными следующие методы
(кроме операторов * и ->, конструктора копирования, оператора присваивания, деструктора и конструктора):
метод get, как и в случае со ScopedPtr,
метод reset — аналогичен reset у ScopedPtr, но освобождает память,
только если счетчик ссылок после декремента равен 0.
*/

#include "SharedPtr.hpp"

void runAllTests() {

    SharedPtr p1;
    {
        SharedPtr p2(new Number(1.1));
        SharedPtr p3(new Number(1.2));
        SharedPtr p4(p2);
//        const SharedPtr& p4(p2);
        SharedPtr p5;
        p5 = p2;
        p5 = p4;
        p1 = p5;
        p3.reset(nullptr);
        p3 = p5;
        p5.reset(nullptr);
        SharedPtr p6;
        SharedPtr p7;
        p7 = p7;
        p7.reset(nullptr);
        p7.reset(new Number(1.3));
        // p7.reset(new Expression("expr3"));
        SharedPtr p8(new Number(1.4));
        // SharedPtr p8(new Expression("expr4"));
        p8.reset(nullptr);
    }
    p1 = p1;
}

int main() {
    runAllTests();
    return 0;
}
/*
Катастрофическая невнимательность. Сразу написал все как надо, даже сказал сам себе "в этой задаче фишка в том, что перед тем, как обращаться к чему-то через указатель - надо сперва проверить что указатель ненулевой". И написал проверку. В двух ситуациях из трех. Весь день ушел на то, чтобы вспомнить про третью ситуацию и обезопасить ее от разыменований нулевого указателя.
Решается без статика, без вспомогательного класса.
Конструкция, содержащая уничтожения объекта и счетчика, копипастом одинаковая в деструкторе, присвоении и ресете.
Любое разыменование - после проверки указателя на ненулевость.
Создание и инициализация - после проверки на существование указываемого объекта.

Задача не сложна, но требует внимательности и понимания каждого действия.
Вот потенциальные ошибки:
1. Хранить счетчик по значению (следовательно, у каждого объекта свой — так не должно быть).
2. Забывать освобождать память (деструктор, оператор присвоения и reset).
3. Удалять указатель там, где нужно было только занулить (те же места).

Первые две ошибки довольно глупые, а с третьей мне пришлось повозиться и поотлаживать. Еще один нюанс, которого от нас явно хотят: не выделять память для нулевых указателей. Таким образом, если у вас отдельная структура типа node для счетчика с указателем, то условия проверки ее счетчика выглядят не как if(node->counter), а как if(node && node->counter). Соответственно, всё остальное должно корректно отрабатывать на случаях, когда там вообще никакого счетчика нет, а просто nullptr.
Кстати, слово nullptr уже, видимо, можно.

use Valgrind to find memory leak

use pointer to counter instead of counter directly

use swap() function from previous samples (for operator=)

... this is not the end of hints
*/